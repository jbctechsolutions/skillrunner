# v1.2.0 MCP Tool Execution - Implementation Plan

**Epic:** MCP Tool Execution for Skillrunner
**Target Release:** February 2026 (3-4 weeks)
**Priority:** High - Blocks effective workflow automation

---

## Epic Overview

Enable skills to execute external tools (filesystem, git, web APIs) via Model Context Protocol (MCP), allowing real workflow automation beyond just reading files.

**Value Proposition:**
- Skills can write files, not just read them
- Skills can run git commands, call APIs, execute safe shell operations
- Enables true agentic workflows (e.g., "Fix this bug and commit the changes")

**Current State:**
- ‚úÖ MCP domain layer implemented (internal/domain/mcp/)
- ‚úÖ MCP adapters implemented (internal/adapters/mcp/)
- ‚úÖ Comprehensive test coverage (8 test files, 2000+ lines)
- ‚ùå No CLI commands to manage MCP servers
- ‚ùå Skills cannot declare tool requirements
- ‚ùå No tool permission system

**Success Criteria:**
- Users can start/stop MCP servers via CLI
- Skills can declare required tools in YAML
- Permission prompts for tool execution (like file permissions)
- At least 2 bundled MCP servers (filesystem, git)
- Documentation and examples

---

## Phase 1: MCP CLI Commands (Week 1-2)

### Issue 1.1: MCP Server Management Commands

**Story:** As a user, I want to manage MCP servers via CLI so I can enable tools for my skills.

**Commands to Implement:**
```bash
sr mcp list-servers              # Show all configured servers
sr mcp start <server-name>       # Start an MCP server
sr mcp stop <server-name>        # Stop a running server
sr mcp restart <server-name>     # Restart a server
sr mcp status <server-name>      # Show detailed server status
sr mcp logs <server-name>        # View server logs
```

**Acceptance Criteria:**
- [ ] All commands implemented in `internal/presentation/cli/commands/mcp.go`
- [ ] Uses existing `ServerManager` from `internal/adapters/mcp/server.go`
- [ ] Proper error handling and user feedback
- [ ] Colors and formatting match existing CLI style
- [ ] Help text and examples for each command
- [ ] Unit tests for command logic

**Technical Approach:**
1. Create `internal/presentation/cli/commands/mcp.go`
2. Define cobra command structure with subcommands
3. Wire up to container's MCP services
4. Use existing `ServerManager` methods (already tested)
5. Format output with existing CLI styling utilities

**Files to Create/Modify:**
- `internal/presentation/cli/commands/mcp.go` (new)
- `internal/presentation/cli/commands/root.go` (register mcp command)
- `internal/presentation/cli/commands/mcp_test.go` (new)

**Dependencies:**
- None (uses existing MCP infrastructure)

**Estimated Effort:** 2-3 days

---

### Issue 1.2: MCP Tool Discovery Commands

**Story:** As a user, I want to discover available MCP tools so I can use them in my skills.

**Commands to Implement:**
```bash
sr mcp list-tools                    # Show all tools from all servers
sr mcp list-tools --server=filesystem  # Show tools from specific server
sr mcp describe-tool <tool-name>     # Show tool details and schema
sr mcp call <tool-name> --args='{}'  # Test a tool manually
```

**Acceptance Criteria:**
- [ ] All commands implemented
- [ ] Tool list shows: name, server, description
- [ ] `describe-tool` shows full JSON schema
- [ ] `call` supports JSON argument input
- [ ] Error handling for missing servers/tools
- [ ] Unit tests for all commands

**Technical Approach:**
1. Add tool commands to `mcp.go`
2. Use `MCPToolRegistryPort.GetAllTools()` (already exists)
3. Use `MCPServerPort.CallTool()` for manual testing
4. Format tool schemas in readable way
5. Support both text and JSON output modes

**Files to Create/Modify:**
- `internal/presentation/cli/commands/mcp.go` (add subcommands)
- `internal/presentation/cli/commands/mcp_test.go` (add tests)

**Dependencies:**
- Issue 1.1 (shares same file)

**Estimated Effort:** 2 days

---

### Issue 1.3: Integrate MCP into Status Command

**Story:** As a user, I want to see MCP server status in `sr status` so I know what tools are available.

**Expected Output:**
```bash
$ sr status

MCP Servers:
  ‚úì filesystem     Running    3 tools available
  ‚úì git            Running    8 tools available
  ‚úó browser        Stopped    (not configured)
```

**Acceptance Criteria:**
- [ ] MCP section added to `sr status` output
- [ ] Shows server name, state, tool count
- [ ] Color coding: green (running), red (stopped/error)
- [ ] Lists available tools with `--detailed` flag
- [ ] Handles case where no MCP servers configured
- [ ] Unit tests

**Technical Approach:**
1. Modify `internal/presentation/cli/commands/status.go`
2. Query `ServerManager.ListServers()`
3. Add new formatting section after providers
4. Reuse existing status output utilities

**Files to Modify:**
- `internal/presentation/cli/commands/status.go`
- `internal/presentation/cli/commands/status_test.go`

**Dependencies:**
- None (existing status command)

**Estimated Effort:** 1 day

---

## Phase 2: Skill Tool Integration (Week 3-4)

### Issue 2.1: Skill Domain Model Extension

**Story:** As a skill author, I want to declare tool requirements in skill YAML so users know what permissions are needed.

**YAML Syntax:**
```yaml
id: file-processor
name: File Processor
description: Process and transform files

# Tool requirements
tools:
  - mcp__filesystem__read_file
  - mcp__filesystem__write_file

phases:
  - id: process
    prompt_template: |
      Process the file: {{.input}}
    allow_tools: true  # Enable tool calling for this phase
```

**Acceptance Criteria:**
- [ ] `Skill` domain model has `Tools []string` field
- [ ] YAML parser reads `tools` section
- [ ] Validation: tools must match `mcp__server__tool` format
- [ ] Phase model has `AllowTools bool` field
- [ ] Unit tests for skill parsing with tools
- [ ] Backward compatible (tools optional)

**Technical Approach:**
1. Extend `internal/domain/skill/skill.go`:
   - Add `Tools []string` field
   - Add `AllowTools bool` to Phase struct
2. Update `internal/infrastructure/skills/loader.go`:
   - Parse `tools` array from YAML
   - Parse `allow_tools` from phase YAML
3. Add validation in `Skill.Validate()`

**Files to Modify:**
- `internal/domain/skill/skill.go`
- `internal/domain/skill/skill_test.go`
- `internal/infrastructure/skills/loader.go`
- `internal/infrastructure/skills/loader_test.go`

**Dependencies:**
- None (pure domain model change)

**Estimated Effort:** 1-2 days

---

### Issue 2.2: Tool Permission System

**Story:** As a user, I want to approve tool execution before skills run so I maintain control over system actions.

**Permission Prompt:**
```bash
$ sr run file-processor "Process data.json"

üîß Tool Permission Request
The skill wants to use 2 tool(s):
  1. filesystem__read_file - Read files from disk
  2. filesystem__write_file - Write files to disk

Allow tool execution? [Y/n/individual/show]
```

**Acceptance Criteria:**
- [ ] Permission prompt before skill execution
- [ ] Four modes: Y (approve all), n (deny), individual, show (describe tools)
- [ ] Auto-approve via `-y` flag
- [ ] Shows tool descriptions from MCP
- [ ] Denying tools aborts execution with clear error
- [ ] Unit tests for permission logic

**Technical Approach:**
1. Create `internal/infrastructure/context/tool_permission.go`:
   - Similar to existing `permission.go` (file permissions)
   - `PromptForTools(tools []mcp.Tool) ([]mcp.Tool, error)`
2. Integrate into workflow executor:
   - Check skill.Tools before execution
   - Prompt user if tools declared
   - Pass approved tools to provider

**Files to Create/Modify:**
- `internal/infrastructure/context/tool_permission.go` (new)
- `internal/infrastructure/context/tool_permission_test.go` (new)
- `internal/application/workflow/executor.go` (add tool permission check)
- `internal/presentation/cli/commands/run.go` (add -y flag support)
- `internal/presentation/cli/commands/ask.go` (add -y flag support)

**Dependencies:**
- Issue 2.1 (needs skill.Tools field)

**Estimated Effort:** 2-3 days

---

### Issue 2.3: Provider Tool Integration

**Story:** As a skill, I want to pass tool definitions to the LLM provider so it can make tool calls during execution.

**Technical Requirements:**
- Convert MCP tools to provider-compatible format
- Pass tools in `CompletionRequest.Tools`
- Handle tool calls in response
- Execute tools via MCP
- Feed tool results back to LLM

**Acceptance Criteria:**
- [ ] Workflow executor fetches tool definitions from MCP registry
- [ ] Tools converted to provider format (using existing converter)
- [ ] Tools passed in `CompletionRequest.Tools`
- [ ] Anthropic adapter handles tool calls correctly
- [ ] Tool execution via `MCPToolRegistryPort.CallToolByFullName()`
- [ ] Tool results passed back to provider for continuation
- [ ] Unit tests for tool calling flow
- [ ] Integration test with real Anthropic API

**Technical Approach:**
1. Modify `internal/application/workflow/phase_executor.go`:
   - Check if phase has `AllowTools: true`
   - Fetch tool definitions from MCP registry
   - Convert using `internal/adapters/mcp/tool_converter.go` (exists)
   - Add to `CompletionRequest.Tools`
2. Modify `internal/adapters/provider/anthropic/client.go`:
   - Handle tool_use content blocks in response
   - Execute tools via MCP registry
   - Continue conversation with tool results
3. Add tool calling to streaming executor too

**Files to Modify:**
- `internal/application/workflow/phase_executor.go`
- `internal/application/workflow/streaming_phase_executor.go`
- `internal/adapters/provider/anthropic/client.go`
- `internal/adapters/provider/anthropic/streaming.go`
- Add integration test file

**Dependencies:**
- Issue 2.1 (needs phase.AllowTools)
- Issue 2.2 (permission system)

**Estimated Effort:** 3-4 days

---

### Issue 2.4: Tool Call Streaming Support

**Story:** As a user, I want to see tool calls happen in real-time during streaming execution.

**Expected Output:**
```bash
$ sr run file-processor "Process data.json" --stream

Phase: Process
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Processing your file...

üîß Calling tool: filesystem__read_file
   Arguments: {"path": "data.json"}
   ‚úì Success (1.2 KB read)

Transforming the data...

üîß Calling tool: filesystem__write_file
   Arguments: {"path": "output.json", "content": "..."}
   ‚úì Success

‚úì Phase complete
```

**Acceptance Criteria:**
- [ ] Tool calls shown in streaming output
- [ ] Tool arguments displayed (truncated if large)
- [ ] Tool results summarized
- [ ] Errors shown clearly
- [ ] Colors match existing streaming output
- [ ] Unit tests

**Technical Approach:**
1. Extend streaming callback to handle tool events
2. Add tool call formatting to output package
3. Show tool calls inline with streaming text
4. Use existing color scheme

**Files to Modify:**
- `internal/presentation/cli/output/streaming.go`
- `internal/presentation/cli/output/streaming_test.go`
- `internal/application/workflow/streaming_phase_executor.go`

**Dependencies:**
- Issue 2.3 (tool calling must work first)

**Estimated Effort:** 2 days

---

## Phase 3: Bundled MCP Servers (Week 5)

### Issue 3.1: Default MCP Server Configurations

**Story:** As a new user, I want useful MCP servers configured by default so I can start using tools immediately.

**Bundled Servers:**
1. **Filesystem Server** - Read/write/list files
2. **Git Server** - Git operations (status, diff, commit, log)

**Configuration File:** `~/.skillrunner/mcp_servers.json`
```json
{
  "filesystem": {
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-filesystem", "${HOME}"],
    "description": "Read and write files on your local filesystem"
  },
  "git": {
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-git"],
    "description": "Execute git commands in your repositories"
  }
}
```

**Acceptance Criteria:**
- [ ] Default config created during `sr init`
- [ ] Config supports ${HOME} and ${PWD} expansion
- [ ] Config validation on load
- [ ] Instructions printed for installing npx/node if missing
- [ ] Documentation of available servers
- [ ] Unit tests for config loading

**Technical Approach:**
1. Create default template in `internal/infrastructure/config/mcp_defaults.go`
2. Modify `sr init` to write MCP config
3. Add config loader to read and parse MCP config
4. Use existing `MCPConfigPort` interface

**Files to Create/Modify:**
- `internal/infrastructure/config/mcp_defaults.go` (new)
- `internal/presentation/cli/commands/init.go` (add MCP config creation)
- `configs/mcp_servers.example.json` (new, for documentation)

**Dependencies:**
- None

**Estimated Effort:** 1-2 days

---

### Issue 3.2: Example Skills Using Tools

**Story:** As a user, I want example skills that use MCP tools so I understand how to create my own.

**Skills to Create:**
1. **file-edit** - Edit files using read/write tools
2. **git-commit** - Generate commit message and commit changes
3. **api-fetch** - Fetch data from web API and save to file

**Acceptance Criteria:**
- [ ] 3 example skills created in `skills/` directory
- [ ] Each skill demonstrates tool usage
- [ ] Clear comments explaining tool declarations
- [ ] Working examples tested end-to-end
- [ ] Added to README skill list
- [ ] Documentation in docs/skills-guide.md

**Technical Approach:**
1. Create skill YAML files with tool declarations
2. Test each skill manually
3. Document in skills guide
4. Add usage examples

**Files to Create:**
- `skills/file-edit.yaml` (new)
- `skills/git-commit.yaml` (new)
- `skills/api-fetch.yaml` (new)
- Update `docs/skills-guide.md`
- Update `README.md`

**Dependencies:**
- Issue 2.1 (skill tool syntax)
- Issue 2.3 (tool execution)
- Issue 3.1 (bundled servers)

**Estimated Effort:** 1-2 days

---

### Issue 3.3: MCP Documentation

**Story:** As a developer, I want comprehensive MCP documentation so I can create tool-enabled skills.

**Documentation Sections:**
1. **MCP Overview** - What is MCP, why use it
2. **Server Management** - Installing, configuring, starting servers
3. **Using Tools in Skills** - YAML syntax, permission system
4. **Available Servers** - List of official MCP servers
5. **Creating Custom Servers** - How to write MCP servers
6. **Troubleshooting** - Common issues and solutions

**Acceptance Criteria:**
- [ ] `docs/mcp-guide.md` created with all sections
- [ ] Code examples for each feature
- [ ] Screenshots of permission prompts
- [ ] Links to official MCP documentation
- [ ] Troubleshooting section with solutions
- [ ] Added to docs/README.md index

**Files to Create:**
- `docs/mcp-guide.md` (new, comprehensive)
- Update `docs/README.md` (add MCP guide to index)
- Update `README.md` (add MCP to features)

**Dependencies:**
- All other issues (document final state)

**Estimated Effort:** 1-2 days

---

## Testing Strategy

### Unit Tests
- All new code must have unit tests
- Target: 80%+ coverage for new files
- Mock MCP servers for testing
- Test permission prompts with stdin/stdout mocking

### Integration Tests
- Test with real MCP servers (filesystem, git)
- Test full skill execution with tool calls
- Test error handling (server crashes, tool failures)

### Manual Testing Checklist
- [ ] Install skillrunner fresh
- [ ] Run `sr init` - verify MCP config created
- [ ] Start filesystem server - verify tools available
- [ ] Run file-edit skill - verify tool permissions work
- [ ] Test all permission modes (Y/n/individual/show)
- [ ] Test `-y` auto-approve flag
- [ ] Test skill with streaming output
- [ ] Test error handling (deny tools, server crash)

---

## Dependencies & Prerequisites

**External Dependencies:**
- Node.js + npx (for running MCP servers)
- Anthropic API key (for testing tool calls with Claude)

**Code Dependencies:**
- All MCP infrastructure already exists (domain + adapters)
- File permission system (v1.1.0) - pattern to follow

**Documentation Dependencies:**
- Claude's MCP documentation: https://modelcontextprotocol.io/

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| MCP servers unreliable | High | Add health checks, auto-restart |
| Tool calls expensive (API costs) | Medium | Clear warnings in docs, cost tracking |
| Permission fatigue | Medium | Smart defaults, `-y` flag for automation |
| npm/npx not installed | Medium | Clear error messages, installation guide |
| Tool execution security | High | Sandboxing, permission system, docs |

---

## Success Metrics

**Launch Metrics:**
- [ ] 2+ bundled MCP servers working
- [ ] 3+ example skills using tools
- [ ] Documentation complete
- [ ] All tests passing (80%+ coverage)
- [ ] Zero P0 bugs

**Post-Launch Metrics (Week 1-2):**
- Tool usage rate (% of skills using tools)
- Most popular tools (track via telemetry)
- Permission denial rate (indicates UX issues)
- Bug reports related to MCP

---

## Release Checklist

- [ ] All issues completed and merged
- [ ] CHANGELOG.md updated
- [ ] README.md updated with MCP features
- [ ] Documentation reviewed and complete
- [ ] All tests passing
- [ ] Manual testing checklist completed
- [ ] Security review (tool execution sandboxing)
- [ ] Performance testing (tool call latency)
- [ ] Create release branch
- [ ] Tag v1.2.0
- [ ] Push to GitHub
- [ ] Create GitHub release with notes
- [ ] Announce in community channels

---

## Future Enhancements (v1.3+)

**Not in v1.2.0, but documented for future:**
- Tool result caching (avoid re-running expensive tools)
- Custom tool timeouts (per-tool configuration)
- Tool usage analytics dashboard
- Browser/puppeteer MCP server
- Database MCP server (SQL queries)
- Shell execution server (sandboxed)
- Tool composition (chain tools together)

---

## Appendix: Technical Architecture

### Tool Execution Flow

```
User runs skill
    ‚Üì
Skill declares tools
    ‚Üì
Permission prompt ‚Üí User approves
    ‚Üì
Workflow executor starts
    ‚Üì
Phase executor prepares request:
  - Fetch tool definitions from MCP registry
  - Convert to provider format
  - Add to CompletionRequest.Tools
    ‚Üì
Provider (Anthropic) sends request
    ‚Üì
Claude decides to call tool
    ‚Üì
Provider receives tool_use block
    ‚Üì
Execute tool via MCP:
  - Parse tool name (mcp__server__tool)
  - Call MCPToolRegistryPort.CallToolByFullName()
  - MCP client sends JSON-RPC request to server
  - Server executes tool
  - Result returned
    ‚Üì
Feed result back to Claude
    ‚Üì
Claude continues generation
    ‚Üì
Final response returned
```

### MCP Server Lifecycle

```
sr mcp start filesystem
    ‚Üì
ServerManager.Start(config)
    ‚Üì
Spawn server process (npx @modelcontextprotocol/server-filesystem)
    ‚Üì
Connect stdio transport
    ‚Üì
Send initialize JSON-RPC request
    ‚Üì
Server responds with capabilities
    ‚Üì
Send initialized notification
    ‚Üì
Server ready (state = Ready)
    ‚Üì
List tools via tools/list request
    ‚Üì
Tools registered in MCPToolRegistryPort
    ‚Üì
[Server runs until stopped]
    ‚Üì
sr mcp stop filesystem
    ‚Üì
Send shutdown notification
    ‚Üì
Close stdio connections
    ‚Üì
Wait for process exit
    ‚Üì
Server stopped (state = Stopped)
```

---

## Contact & Support

**Project Lead:** Joel Castillo (joel@jbc.dev)
**Repository:** https://github.com/jbctechsolutions/skillrunner
**Documentation:** https://github.com/jbctechsolutions/skillrunner/tree/main/docs

For questions about this plan, create a discussion in the GitHub repository.
